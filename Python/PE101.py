##Problem 101
##
##If we are presented with the first k terms of a sequence it is impossible to say with certainty the value of the next term, as there are infinitely many polynomial functions that can model the sequence.
##
##As an example, let us consider the sequence of cube numbers. This is defined by the generating function,
##un = n3: 1, 8, 27, 64, 125, 216, ...
##
##Suppose we were only given the first two terms of this sequence. Working on the principle that "simple is best" we should assume a linear relationship and predict the next term to be 15 (common difference 7). Even if we were presented with the first three terms, by the same principle of simplicity, a quadratic relationship should be assumed.
##
##We shall define OP(k, n) to be the nth term of the optimum polynomial generating function for the first k terms of a sequence. It should be clear that OP(k, n) will accurately generate the terms of the sequence for n ≤ k, and potentially the first incorrect term (FIT) will be OP(k, k+1); in which case we shall call it a bad OP (BOP).
##
##As a basis, if we were only given the first term of sequence, it would be most sensible to assume constancy; that is, for n ≥ 2, OP(1, n) = u1.
##
##Hence we obtain the following OPs for the cubic sequence:
##OP(1, n) = 1 	1, 1, 1, 1, ...
##OP(2, n) = 7*n−6 	1, 8, 15, ...
##OP(3, n) = 6*n**2−11*n+6      	1, 8, 27, 58, ...
##OP(4, n) = n**3 	1, 8, 27, 64, 125, ...
##
##Clearly no BOPs exist for k ≥ 4.
##
##By considering the sum of FITs generated by the BOPs (indicated in red above), we obtain 1 + 15 + 58 = 74.
##
##Consider the following tenth degree polynomial generating function:
##
##un = 1 − n + n2 − n3 + n4 − n5 + n6 − n7 + n8 − n9 + n10
##
##Find the sum of FITs for the BOPs.


##def Lagrange_off(X, Y):
##    """
##    Retourne le polynome de Lagrange passant par les points (X[i] ; Y[i])
##    """
##    n = len(X)
##    Mat = [[0]*n]*n
##    print(Mat)
##    for i in range(n):
##        for j in range(n):
##            print("i, j=",i, j)
##            if (j!=0 and j!=n-1) or (j==n-1 and i==0):
##                #cas courant
##                if i == j:
##                    Mat[i][j] = lambda x:Mat[i][j-1](x) * Y[i]
##                else:
##                    Mat[i][j] = lambda x:Mat[i][j-1](x) * (x-X[j])/(X[i]-X[j])
##            elif j == n-1:
##                #fin de ligne avec i!=0
##                if i == j:
##                    Mat[i][j] = lambda x:Mat[i-1][j](x) + Mat[i][j-1](x) * Y[i]
##                else:
##                    Mat[i][j] = lambda x:Mat[i-1][j](x) + Mat[i][j-1](x) * (x-X[j])/(X[i]-X[j])
##            else:
##                #début de ligne
##                if i == j:
##                    Mat[i][j] = lambda x:Y[i]
##                else:
##                    Mat[i][j] = lambda x:(x-X[j])/(X[i]-X[j])
##    print("hop")
##    return Mat[-1][-1]

def Lagrange(X, Y, x):
    """
    Retourne le polynome de Lagrange passant par les points (X[i] ; Y[i])
    """
    n = len(X)
    s = 0
    for i in range(n):
        p = 1
        for j in range(n):
            if i==j:
                p *= Y[i]
            else:
                p *= (x-X[j])/(X[i]-X[j])
        s += p
    return s


Un = lambda n:1-n+n**2-n**3+n**4-n**5+n**6-n**7+n**8-n**9+n**10
#Un = lambda n:n**3


X = [i for i in range(1, 20)]
Y = [Un(x) for x in X]

ordreMax = 10
s = 0
for ordre in range(1,ordreMax + 1):
    X_ = X[:ordre]
    Y_ = Y[:ordre]
    i = 0
    while Y[i] == Lagrange(X_,Y_,X[i]):
        i += 1
    print(ordre,i, Lagrange(X_,Y_,X[i]))
    s += Lagrange(X_,Y_,X[i])

print(s)    








                
    
    



